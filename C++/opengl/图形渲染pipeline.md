# 图形渲染 Pipeline

![pipeline](./pipeline.png)

蓝色为可自定义，灰色不可自定义，整个过程都会在 GPU 中进行

## 顶点着色器

顶点数据会提供给顶点着色器，顶点着色器将会把数据转会为在**标准化设备坐标**中，这是一个 xyz 范围-1.0 到 1.0 的坐标世界，落在这个坐标世界之外的数据将会被丢弃
在**标准化设备坐标**中的坐标会被**glViewport**函数进行视口变换转换为**屏幕空间坐标**

OpenGL 希望在每次顶点着色器运行后，我们可见的所有顶点都为**标准化设备坐标**(Normalized Device Coordinate, NDC)。也就是说，每个顶点的 x，y，z 坐标都应该在-1.0 到 1.0 之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。

顶点着色器处理的顶点数据被存储在顶点缓冲对象（Vertex Buffer Objects, VBO）里进行管理
gl_Position 就是将要输出的结果，是一个 vec4（x,y,z,w)的向量

## 形状（图元）装配

将顶点着色器提供的顶点作为输入，将这些点装配成指定图元的形状（把点连成形状（？

## 几何着色器

把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。

## 光栅化阶段

图元映射为屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。

## 片段着色器

片段着色器的主要目的是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。

## Alpha 测试和混合(blending)

判断像素是否在前面，是否应该被渲染，透明度的会与其他物体进行混合，因此可能和片段着色器得到的颜色像素完全不同

## 处理顶点数据

![vertex](./vertex_array_objects_ebo.png)

源数据可能被多次使用，因此通过 VAO 的方式进行缓存。VAO 中的数据可能将会被复用，为减少数据量，因此通过 EBO 来使得通过 index 调用的方式重复使用源数据，数据将会传给 VBO 提供给实际将要进行绘制的节点，并依靠对应的步长，偏移，等方式去决定如何绘制
